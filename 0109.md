---
title: "You Don't Know JS: 클래스와 객체의 혼합"
date: 2018-01-09T16:17:08+09:00
draft: false
categories: ['TIL-2018']
tags: ['javascript']
---

앞 장에서 다룬 객체와 이번 장의 내용을 통해 자바스크립트 데이터로써 객체(Object type) 개념보다 확장된, 개발 패턴으로서의 객체 개념을 조금이나마 이해할 수 있었다.

# 클래스와 객체의 혼합

> 클래스와 상속은 (...) 실생활 영역의 문제를 소프트웨어로 모델링 하기 위한 방법이다. (...) 객체 지향 또는 클래스 지향 프로그래밍에서 (...) 데이터와 작동을 함께 잘 감싸는 것이 올바른 설계라고 강조한다; Capsulation.

본문에선 내장 객체 `String`을 예로 든다. 즉 데이터(문자열 타입)와 관련 동작(문자열 타입 데이터에 필요한 메소드)을 캡슐화한 결과가 바로 자바스크립트의 Native Object, String이다. 실생활을 모델링했다는 의미는 "특정 데이터와 그에 대한 동작끼리 묶는 것이 효율적이다"는 보편적인 인식을 의미한다고 생각한다.

> 소프트웨어에서는 이런 관계를 Vehicle 클래스, Car 클래스로 각각 모델링 한다. (...) Car는 Vehicle에 있는 기반 정의를 상속(확장)받아 정의한다. Car가 일반적인 Vehicle의 정의를 세분화한 셈이다.

포괄적인 정의를 먼저 내리고, 보다 세부적인 정의로 세분화한다. 반복적인 코드 줄이기(생산성 관점이지만 자연스럽지 못하면 오히려 저해되는, 리팩토링으로 보완되려나?), 보편적으로 합리적인 논리적 절차에 따른 프로그램(기계가 보기에 좋았더라), 가독성 좋은 코드(사람이 보기에 좋았더라)를 구현하기 위한 방식쯤 되려나.

> (...) 클래스 역시 디자인 패턴의 일종이란 생각은 한 번도 해본 적이 없을 것이다. (...) 클래스가 과연 모든 코드의 근본적인 기초일까 아니면 코드를 선택적으로 추상화한 것일까란 의문을 품는 자체가 어색하게 느껴질 것이다.

> (...) 클래스 디자인 패턴을 실현하려는 욕구를 충족시키고자 많은 변신을 거듭해왔다.

ES6의 class가 등장한 배경과 그 동작원리가 달리 있는 것이 아닌 syntactic-sugar의 결과라는 사실을 어렴풋이 알고있어서 다행(?)이다. 한편으로는 주니어 개발자에게 요구하는 조건인 "OOP에 대한 이해"의 진의가 궁금해진다. 함수형 프로그래밍 패러다임과의 차이와 장, 단점을 알고있음을 의미하거나, 닥치고 OOP겠지. 내 목적은 둘의 차이를 이해하는 것과 자바스크립트에 걸맞는 패러다임을 판단하는 방법을 아는 것이다.

클래스와 인스턴스, 상속의 개념적 이해를 돕기위해 흔히 부모 자식관계에 비유하곤 한다.

> 클래스 지향 언어에서는 (...) 첫 번째 클래스를 상속받는 두 번째 클래스를 정의할 수 있다. 이때 첫 번째 클래스를 '부모 클래스', 두 번째 클래스를 '자식 클래스'라고 통칭한다. 부모/자식 간의 관계를 비유하다 보니 굳혀진 용어지만 실은 **적잖이 왜곡된 비유다**.

객체지향 프로그래밍과 클래스 기반 언어, 이를 프로토타입으로 구현한 자바스크립트에 대해 배우면서 나 역시 여러번 접한 비유. 객체 지향 패러다임에 대한 비판과 위의 왜곡이 관련있는지 궁금하지만 아직은 알 수 없다..

> 부모가 나중에 다 컸을 때 대화를 나눌 실제 자식을 낳으려면 한 벌의 DNA를 조합하여 새 생명을 잉태(인스턴스화)해야 한다. (...) 그런데 만일 클래스가 상속을 두 클래스로부터 받는다면 앞의 부모/자식 비유와 잘 들어맞을 것 같다.

위 비유를 보다 충실히 구현한 모델로 다중 상속개념이 등장하며, 이름이 같은 메소드를 양 쪽에서 상속하려할 때의 문제(마름모 문제)는 짤막하게 언급된다. Angular, TypeScript를 쓸 때 응용했던 `implements`, 덕타이핑 등이 여기에 해당한다. *의존성 주입 시스템은 모계 사회를 보다 사실적으로 구현한 것인가...*

명시적 믹스인(자바스크립트의 `extend` 기능)의 의사코드 구현

```js
function mixin(sourceObj, targetObj) {
    for (var key in sourceObj) {
        if (!(key in targetObj)) {
            targetObj[key] = sourceObj[key];
        }
    }
    return targetObj;
}

var Vehicle = {
    engines: 1,
    ingnition: function() { console.log('engine starts.'); },
    drive: function() { console.log('vehicle moves'); }
}

var Car = mixin(Vehicle, {
    wheels: 4,
    drive: function() {
        // Vehicle, Drive 각각에 모두 존재하기 때문에 명시적으로 호출(명시적 (의사)다형성)
        Vehicle.drive.call(this); // this instanceof Car 
        console.log('car moves with' + this.wheels + 'wheels')
    }
})
```

명시적/암시적 특징을 모두 가지는 믹스인 패턴은 Car의 메소드 내부에서 Vehicle 메소드를 호출하기 이전에, 내부 레퍼런스에 별도로 저장한 것이 그 차이점이다. 나중에 프로토타입 작동위임을 통해 자세히 다룬다고 하니까 적당히 이해하고 넘어가자...

# 참고자료

1. 카일 심슨. (2017). *You Don't Know JS:This와 객체 프로토타입 비동기와 성능*. 한빛미디어
2. 조영호, *객체지향의 사실과 오해*, 위키북스
3. nacyot, *프로그래밍은 왜 어려운가 - 벤 프라이(Ben Fry)의 Distellamap으로 생각해보는 다익스트라의 'GOTO문은 해롭다(Go To Statement Considered Harmful)'*, [nacyot의 프로그래밍 이야기](http://blog.nacyot.com/articles/2015-12-02-programming-is-difficult/)